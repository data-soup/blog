<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://data-soup.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://data-soup.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-04-20T15:26:31-05:00</updated><id>https://data-soup.github.io/blog/feed.xml</id><title type="html">data soup</title><subtitle>üçú</subtitle><entry><title type="html">Overview of One Year of Lottery Ticket Research</title><link href="https://data-soup.github.io/blog/2020/02/13/winning-ticket-overview.html" rel="alternate" type="text/html" title="Overview of One Year of Lottery Ticket Research" /><published>2020-02-13T14:39:28-06:00</published><updated>2020-02-13T14:39:28-06:00</updated><id>https://data-soup.github.io/blog/2020/02/13/winning-ticket-overview</id><content type="html" xml:base="https://data-soup.github.io/blog/2020/02/13/winning-ticket-overview.html">&lt;p&gt;Winning tickets were &lt;a href=&quot;https://arxiv.org/abs/1803.03635&quot;&gt;discovered in March 2018&lt;/a&gt; and presented at ICRL the same year. It drawed a lot of attention. It sheds light on yet unknown underlying properties of neural networks and seems to be one of the keys for faster training and smaller models. Overall flipping on the head how we approach neural net architecture design.&lt;/p&gt;

&lt;p&gt;Winning tickets in deep learning were mentioned as one of the most important topics of 2019 by Lex Fridman‚Äôs in his &lt;a href=&quot;https://youtu.be/0VH1Lim8gL8?t=2761&quot;&gt;Deep Learning State of the Art 2020&lt;/a&gt; (awesome) lecture. This article aims at summarizing what I understood after reading about it. Hope you‚Äôll enjoy it.&lt;/p&gt;

&lt;h1 id=&quot;pruning&quot;&gt;Pruning&lt;/h1&gt;

&lt;p&gt;It is known that DL models have generally heavy computational requirements and can be blocking in particular settings. ResNet, for instance, requires 50M operations for one single inference. They‚Äôve been efforts to reduce the number of parameters with &lt;a href=&quot;https://pytorch.org/docs/stable/quantization.html&quot;&gt;quantization&lt;/a&gt;,
&lt;a href=&quot;https://towardsdatascience.com/what-is-knowledge-distillation-41bb77a3c6d8&quot;&gt;knowledge distillation&lt;/a&gt; and &lt;a href=&quot;https://github.com/he-y/Awesome-Pruning&quot;&gt;pruning&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Pruning removes the &lt;em&gt;least important&lt;/em&gt; weights or channels. Least important can mean the one with the smallest magnitudes or other heuristics. Such a technique is working well and can reduce up to 90% of the weights in a network while preserving most of the original accuracy. While pruning can help to reduce the model‚Äôs size, it won‚Äôt help training it faster. It is generally a post-processing step, after training. Retraining a pruned model won‚Äôt yield the same results as if you prune after training. If it were possible to be able to train the pruned model directly, train faster without sacrificing performances.&lt;/p&gt;

&lt;p&gt;But in their paper &lt;a href=&quot;https://arxiv.org/search/cs?searchtype=author&amp;amp;query=Frankle%2C+J&quot;&gt;Jonathan Frankle&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/search/cs?searchtype=author&amp;amp;query=Carbin%2C+M&quot;&gt;Michael Carbin&lt;/a&gt; experimentally found that instead of training large networks and then reduce their size we might be able to train smaller networks upfront:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;dense, randomly-initialized, feed-forward networks contain subnetworks (‚Äúwinning tickets‚Äù) that - when trained in isolation - reach test accuracy comparable to the original network in a similar number of iterations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;winning-tickets&quot;&gt;Winning Tickets&lt;/h1&gt;

&lt;p&gt;In order to find winning tickets, initialization seems to be the key:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When their parameters are randomly reinitialized [‚Ä¶], our winning tickets no longer match the performance of the original network, offering evidence that these smaller networks do not train effectively unless they are appropriately initialized.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;They found that we can train a pruned model again after re-initializing the weights with the original model‚Äôs parameters. This gives systematically better results than re-initializing randomly. Doing this process multiple times is called iterative pruning (with no re-init):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Randomly initialize a neural network [with weights Œ∏0]
2. Train the network for j iterations, arriving at parameters Œ∏j 
3. Prune [by magnitude] p% of the parameters in Œ∏j , creating a mask m
4. Reset the remaining parameters to their values in Œ∏0
5. Goto 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the subnetwork produced by this technique matches the original network‚Äôs performances, it is called a winning ticket. The following graph represents averaged results of five runs on a LeNet (fully dense) network on the MNIST dataset. This model was pruned in different ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[blue] Done with the recipe above&lt;/li&gt;
  &lt;li&gt;[orange] Same as blue but replace step 4 by ‚ÄúRandomly initialize the remaining parameters‚Äù&lt;/li&gt;
  &lt;li&gt;[red] Same as the orange line without step 5&lt;/li&gt;
  &lt;li&gt;[green] Same as blue without step 5&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/winning-ticket/figure4-b.png&quot; alt=&quot;Figure 4-b of 803.03635&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that step 4 is the key as the green and blue lines are consistently performing better and are trained faster than randomly re-initialized networks. They also found similar results with convolutional networks like VGG and ResNet on MNIST and CIFAR10 (there are &lt;em&gt;many&lt;/em&gt; more details in the &lt;a href=&quot;https://arxiv.org/abs/1803.03635&quot;&gt;original paper&lt;/a&gt;).&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;pruning-early&quot;&gt;Pruning Early&lt;/h1&gt;

&lt;p&gt;But the method above seems to struggle against deeper networks. In a &lt;a href=&quot;https://arxiv.org/abs/1903.01611&quot;&gt;follow-up paper&lt;/a&gt; (March 2019), the authors changed slightly the way the remaining parameters are reset (step 4):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rather than set the weights of a winning ticket to their original initializations, we set them to the weights obtained after a small number of training iterations (&lt;em&gt;late resetting&lt;/em&gt;). Using late resetting, we identify the first winning tickets for Resnet-50 on Imagenet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The graph below plot performances against different levels of sparsity of deep models rewound (iteration at which we reset the weights) with different values. We can see that rewinding at iteration 0 does not perform better than the original network whereas rewinding at higher iteration does:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/winning-ticket/figure8-followup.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Those deeper models were resisting the winning ticket recipe above but found something interesting after looking at their &lt;em&gt;stability&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Stability to pruning&lt;/em&gt;: ‚Äúthe distance between the weights of a
subnetwork trained in isolation and the weights of the same subnetwork when trained within the larger network‚Äù. Which captures ‚Äúa subnetwork‚Äôs ability to train in isolation and still reach the same destination as the larger network‚Äù. If a neuron is stable it won‚Äôt be much affected by its neighbors disappearing through masking.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Stability to data order&lt;/em&gt;: ‚Äúthe distance between the weights of two copies of a subnetwork trained with different data orders‚Äù. Which captures ‚Äú a subnetwork‚Äôs intrinsic ability to consistently reach the same destination despite the gradient noise of SGD‚Äù.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The table below shows stability for different networks. &lt;em&gt;Warmup&lt;/em&gt; means that the learning rate is scheduled to increase slowly during training, possibly reducing the noise of the optimizer. &lt;em&gt;IMP&lt;/em&gt; is the original recipe to generate winning tickets:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/winning-ticket/figure3-followup.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that IMP fails at fiding winning tickets in deeper networks without changing the learning rate. We can also see that there‚Äôs a link between performances and the stabilities measures. ‚ÄúWinning tickets are more stable than the random subnetworks‚Äù.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;what-about-other-domains&quot;&gt;What about other domains?&lt;/h1&gt;

&lt;p&gt;So far winning tickets have been tested on the same datasets and on computer vision tasks. One can ask if this isn‚Äôt just drastic overfitting or if the winning tickets transfer at all.&lt;/p&gt;

&lt;p&gt;Facebook &lt;a href=&quot;https://arxiv.org/abs/1906.02773&quot;&gt;published a paper&lt;/a&gt; (June 2019) tested the winning ticket evaluation and transfer across six visual datasets. For instance, testing generating winning tickets on ImageNet and testing it others (like CIFAR-100):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/winning-ticket/figure4-e.png&quot; alt=&quot;figure 4-e of 1906.02773&quot; /&gt;&lt;/p&gt;

&lt;p&gt;They observed that winning tickets generalize across all datasets with (at least) close performances than the original one. And that winning tickets generated on larger datasets generalized better than the other ones, probably due to the number of classes in the original model. Finally, this paper also tested the transfer successfully across different optimizers successfully.&lt;/p&gt;

&lt;p&gt;What about other tasks than image classification? Facebook &lt;a href=&quot;https://arxiv.org/abs/1906.02768&quot;&gt;published in parallel a paper&lt;/a&gt; (June 2019) that test the winning ticket in reinforcement learning and NLP tasks.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For NLP, we found that winning ticket initializations beat random tickets both for recurrent LSTM models trained on language modeling and Transformer models trained on machine translation. [‚Ä¶] For RL, we found that winning ticket initializations substantially outperformed random tickets on classic control problems and for many, but not all, Atari games.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;tldr&quot;&gt;TLDR&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Many neural networks are over-parameterized&lt;/li&gt;
  &lt;li&gt;Frankle &amp;amp; Carbin found simple algorithm to find smaller network within larger ones&lt;/li&gt;
  &lt;li&gt;Those sub-networks are trainable from scratch and can perform at least as well and often better&lt;/li&gt;
  &lt;li&gt;What makes winning tickets special is still unclear but seems to be a critical step toward a deeper understanding of the underlying properties of neural nets&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;sources&quot;&gt;Sources&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1803.03635&quot;&gt;The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1903.01611&quot;&gt;Stabilizing the Lottery Ticket Hypothesis&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1906.02773&quot;&gt;One ticket to win them all: generalizing lottery ticket initializations across datasets and optimizers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1906.02768&quot;&gt;Playing the lottery with rewards and multiple languages: lottery tickets in RL and NLP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Winning tickets were discovered in March 2018 and presented at ICRL the same year. It drawed a lot of attention. It sheds light on yet unknown underlying properties of neural networks and seems to be one of the keys for faster training and smaller models. Overall flipping on the head how we approach neural net architecture design.</summary></entry><entry><title type="html">Paper Summary. Unsupervised learning by competing hidden units</title><link href="https://data-soup.github.io/blog/2019/06/17/unsupervised-learning-competing-hidden-units.html" rel="alternate" type="text/html" title="Paper Summary. Unsupervised learning by competing hidden units" /><published>2019-06-17T16:00:55-05:00</published><updated>2019-06-17T16:00:55-05:00</updated><id>https://data-soup.github.io/blog/2019/06/17/unsupervised-learning-competing-hidden-units</id><content type="html" xml:base="https://data-soup.github.io/blog/2019/06/17/unsupervised-learning-competing-hidden-units.html">&lt;p&gt;This is a summary of &lt;a href=&quot;https://www.pnas.org/content/pnas/116/16/7723.full.pdf&quot;&gt;Unsupervised learning by competing hidden units&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This paper introduces a novel unsupervised learning technique. There‚Äôs (almost) no backprop and the model isn‚Äôt trained for a particular task. The two authors, coming from neuroscience and computer science backgrounds based this work on two biological observations:&lt;/p&gt;

&lt;p&gt;1- Synapses changes are local:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In biology, the synapse update depends on the activities of the presynaptic cell and the postsynaptic cell and perhaps on some global variables such as how well the task was carried out. (page 1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The weight of a cell between A and B trained with backpropagation not only depends on the activity of A and B but also on the previous layer‚Äôs activity and the training labels. So it doesn‚Äôt depend on A, B activity but other potentially any other neurons in the network. This is inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Hebbian_theory&quot;&gt;Hebb&lt;/a&gt;‚Äôs idea.&lt;/p&gt;

&lt;p&gt;2- Animals learn without labeled data and fewer data than neural networks trained with backpropagation:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Second, higher animals require extensive sensory experience to tune the early [‚Ä¶] visual system into an adult system. This experience is believed to be predominantly observational, with few or no labels, so that there is no explicit task. (page 1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;unsupervised-local-training&quot;&gt;Unsupervised local training&lt;/h3&gt;

&lt;p&gt;Authors managed to train their model on MNIST and CIFAR-10 with only forward passes, meaning:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;This technique is less computationally demanding, its computational complexity is comparable to the computational complexity of the forward pass in backpropagation (&lt;a href=&quot;https://youtu.be/4lY-oAY0aQU?t=1581&quot;&gt;source&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;Doesn‚Äôt require to train the model on a given task to make meaningful representation from the data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The blue rectangles are the authors ‚Äúbiological learning algorithm‚Äù. First, the data is going through it, without any label or any indication on the task it‚Äôll be used for. Once trained a fully connected network is appended on top of it in order to specialize the model and make the desired predictions. This part is trained using backpropagation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/competing-hidden-units/fig01-training-schema.png&quot; alt=&quot;figure 01, page 02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Usually to compute the activity of the hidden layer &lt;code class=&quot;highlighter-rouge&quot;&gt;hŒº&lt;/code&gt;, we project the input &lt;code class=&quot;highlighter-rouge&quot;&gt;vi&lt;/code&gt; on it by multiplying it with a matrix &lt;code class=&quot;highlighter-rouge&quot;&gt;WŒºi&lt;/code&gt; and then apply non-linearity. In this new technique the &lt;code class=&quot;highlighter-rouge&quot;&gt;hŒº&lt;/code&gt; activity is computed solving this differential equation:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/competing-hidden-units/eq8-learning-rule.png&quot; alt=&quot;equation 08, page 04&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Œº&lt;/code&gt; is the index of the hidden layer we want to update&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;œÑ&lt;/code&gt; is a timescale of the process&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IŒº&lt;/code&gt; is the input current&lt;/li&gt;
  &lt;li&gt;The second term, the sum of all other hidden layers, introduce competition between neurons. Stronger units will inhibit weaker ones. Without it, all neurons will fire activation when input is shown. Note that this term introduces lateral connections between units since they units within the same layer can be connected to each other.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; is a ReLU and &lt;code class=&quot;highlighter-rouge&quot;&gt;winh&lt;/code&gt; is a hyperparameter constant.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since training is local and requires only forward passes, this architecture is different from an auto-encoder.&lt;/p&gt;

&lt;h3 id=&quot;in-action&quot;&gt;In action&lt;/h3&gt;

&lt;p&gt;In an experiment on MNIST and CIFAR-10, the authors trained 2000 hidden units using their biological technique to find the matrix &lt;code class=&quot;highlighter-rouge&quot;&gt;WŒºi&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hidden units were initialized with a normal distribution&lt;/li&gt;
  &lt;li&gt;Hidden units are trained (again, without explicit task or labels)&lt;/li&gt;
  &lt;li&gt;Those units are then frozen and plugged to a perceptron&lt;/li&gt;
  &lt;li&gt;The perceptron weights were trained using SGD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The training error on MNIST can be seen in the rightmost figure of the image below (BP stands for backpropagation and BIO for the proposed approach). We can see that despite a higher training error, the testing error is very close to the model trained end-to-end.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/competing-hidden-units/fig-03-mnist-in-action.png&quot; alt=&quot;figure 03, page 05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;On MNIST, we can see that the features learned by the proposed biological learning algorithm (left figure) are different from the one trained with backpropagation (middle figure).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;the network learns a distributed representation of the
data over multiple hidden units. This representation, however, is
very different from the representation learned by the network
trained end-to-end, as is clear from comparison of Fig. 3, Left
and Center.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Similarly for CIFAR-10:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/competing-hidden-units/fig-07-cifar-in-action.png&quot; alt=&quot;figure 07, page 07&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tldr&quot;&gt;tldr&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;no top‚Äìdown propagation of information, the synaptic weights are learned using only bottom-up signals, and the algorithm is agnostic about the task that the network will have to solve eventually in the top layer (page 8)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;A new unsupervised training technique, where the task isn‚Äôt defined, the training set goes through the model and is trained without backpropagation. A fully connected perceptron is appended on top, trained with backpropagation with the lower unsupervised submodel is frozen.&lt;/li&gt;
  &lt;li&gt;This technique shows poorer but near state of the art generalizations performances on MNIST and CIFAR.&lt;/li&gt;
  &lt;li&gt;There‚Äôs no forward/backward, each cell is potentially connected to every other, including on its own layer.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Author&lt;/th&gt;
      &lt;th&gt;Organization&lt;/th&gt;
      &lt;th&gt;Previous work&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://researcher.watson.ibm.com/researcher/view.php?person=ibm-krotov&quot;&gt;Dmitry Krotov&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;MIT, IBM (Watson, Research), Princeton&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://arxiv.org/abs/1701.00939&quot;&gt;Dense Associative Memory Is Robust to Adversarial Inputs&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;http://pni.princeton.edu/john-hopfield&quot;&gt;John J. Hopfield&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Princeton Neuroscience Institute&lt;/td&gt;
      &lt;td&gt;same&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Complementary resources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=4lY-oAY0aQU&quot;&gt;Video presentation&lt;/a&gt;  by one of the authors at MIT.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/DimaKrotov/Biological_Learning/blob/master/Unsupervised_learning_algorithm_MNIST.ipynb&quot;&gt;Github&lt;/a&gt; for reproduction.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/blogs/research/2019/04/biological-algorithm/&quot;&gt;Blog post&lt;/a&gt; on IBM‚Äôs blog.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">This is a summary of Unsupervised learning by competing hidden units.</summary></entry><entry><title type="html">Paper Summary. Stiffness: A New Perspective on Generalization in Neural Networks</title><link href="https://data-soup.github.io/blog/2019/03/28/stiffness-new-perspecive-generalization.html" rel="alternate" type="text/html" title="Paper Summary. Stiffness: A New Perspective on Generalization in Neural Networks" /><published>2019-03-28T16:00:55-05:00</published><updated>2019-03-28T16:00:55-05:00</updated><id>https://data-soup.github.io/blog/2019/03/28/stiffness-new-perspecive-generalization</id><content type="html" xml:base="https://data-soup.github.io/blog/2019/03/28/stiffness-new-perspecive-generalization.html">&lt;p&gt;This is a summary of &lt;a href=&quot;https://arxiv.org/pdf/1901.09491.pdf&quot;&gt;Stiffness: A New Perspective on Generalization in Neural Networks&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;stiffness&quot;&gt;Stiffness?&lt;/h3&gt;

&lt;p&gt;This paper aims at improving our understanding of how neural networks generalize from the point of view of &lt;em&gt;stiffness&lt;/em&gt;. The intuition behind stiffness is how a gradient update on one point affects another:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[it] characterizes the amount of correlation between changes in loss on the two due to the application of a gradient update based on one of them. (4.1, Results and discussion)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Stiffness is expressed as the expected sign of the gradients &lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/stiffness/formula_stiffness.png&quot; alt=&quot;Formula 5, page 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A weight update that improves the loss for &lt;strong&gt;X_1&lt;/strong&gt; and &lt;strong&gt;X_2&lt;/strong&gt; is stiff and characterized as anti-stiff if the loss beneficiate for one of the points and doesn‚Äôt help the other.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/stiffness/figure1_stiffness_overview.png&quot; alt=&quot;Figure 1, page 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The question is now how do we choose &lt;strong&gt;X_1&lt;/strong&gt; and &lt;strong&gt;X_2&lt;/strong&gt;. Authors explore two ways: by class membership or by distance.&lt;/p&gt;

&lt;h3 id=&quot;stiffness-based-on-class-membership&quot;&gt;Stiffness based on class membership&lt;/h3&gt;

&lt;p&gt;We can look at how a gradient update on a point in class A will affect another point‚Äôs loss belonging to class B. In the paper they craft a *class stiffness matrix`, which is the average of stiffness between each point grouped by class:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/stiffness/formula06-class-membership.png&quot; alt=&quot;Formula 6, page 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The diagonal of this matrix represent the model‚Äôs within class generalization capability. You can find an example of stiffness class matrix at different steps of the training stage:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/stiffness/figure06-page5.png&quot; alt=&quot;Figugre 6, page 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At early stages, the stiffness is high between members of the same classes (hence the red diagonal). The majority of the cells raises their stiffness until reaching the point of overfitting: stiffness reaches 0.&lt;/p&gt;

&lt;h3 id=&quot;stiffness-as-a-function-distance-and-learning-rate&quot;&gt;Stiffness as a function distance and learning rate&lt;/h3&gt;
&lt;p&gt;Stiffness is then studied through the distance lens, they distinguish two kinds of distance: pixel-wise (in the input space) and layerwise (in the representational space).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/stiffness/figure9_depending_on_distance.png&quot; alt=&quot;Figure 9, page 6&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The general pattern visible in Figure 9 is that there exists a critical distance within which input data points tend to move together under gradient updates, i.e. have positive stiffness. This holds true for all layers in the network, with the tendency of deeper layers to have smaller stiff domain sizes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Authors define stiff regions as ‚Äúregions of the data space that move together when a gradient update is applied‚Äù.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/stiffness/figure10-stiffdomain-learningrate.png&quot; alt=&quot;Figure 10, page 7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that a higher learning rate increase the size of the stiff regions which suggests that higher learning rates help generalization.&lt;/p&gt;

&lt;h3 id=&quot;tldr&quot;&gt;tldr&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Stiffness quantify how much gradient update on one group of point affects another&lt;/li&gt;
  &lt;li&gt;Stiffness is tightly linked to generalization&lt;/li&gt;
  &lt;li&gt;Stiffness tends to 0 when the system overfit&lt;/li&gt;
  &lt;li&gt;Higher learning rate increases the area under which points are moving together&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Author&lt;/th&gt;
      &lt;th&gt;Organization&lt;/th&gt;
      &lt;th&gt;Previous work&lt;/th&gt;
      &lt;th&gt;¬†&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;http://stanford.edu/~sfort1/&quot;&gt;Stanislav Fort&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Google AI Resident, Google AI Zurich&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://arxiv.org/pdf/1807.02581.pdf&quot;&gt;The Goldilocks zone: Towards better understanding of neural network loss landscapes&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;¬†&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Pawe≈Ç Krzysztof Nowak&lt;/td&gt;
      &lt;td&gt;Google AI Resident&lt;/td&gt;
      &lt;td&gt;¬†&lt;/td&gt;
      &lt;td&gt;¬†&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://ai.google/research/people/SriniNarayanan&quot;&gt;Srini Narayanan&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Google AI Resident&lt;/td&gt;
      &lt;td&gt;¬†&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://ai.google/research/pubs/pub47017&quot;&gt;Points, Paths, and Playscapes: Large-scale Spatial Language Understanding Tasks Set in the Real World&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Complementary resources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Manifold Mixup: Better Representations by Interpolating Hidden States - https://arxiv.org/abs/1806.05236 (cited in the article)&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">This is a summary of Stiffness: A New Perspective on Generalization in Neural Networks.</summary></entry><entry><title type="html">What is Knowledge Distillation?</title><link href="https://data-soup.github.io/blog/2018/11/22/knowledge-distillation.html" rel="alternate" type="text/html" title="What is Knowledge Distillation?" /><published>2018-11-22T07:37:55-06:00</published><updated>2018-11-22T07:37:55-06:00</updated><id>https://data-soup.github.io/blog/2018/11/22/knowledge-distillation</id><content type="html" xml:base="https://data-soup.github.io/blog/2018/11/22/knowledge-distillation.html">&lt;p&gt;Knowledge distillation is a fascinating concept, we‚Äôll cover briefly why we need it, how it works.&lt;/p&gt;

&lt;h2 id=&quot;Ô∏è-weight-matters&quot;&gt;‚öñÔ∏è Weight Matters&lt;/h2&gt;

&lt;p&gt;Today‚Äôs models can be quite large, here are some of the top models for the ImageNet dataset:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Model&lt;/th&gt;
      &lt;th&gt;Weights (millions)&lt;/th&gt;
      &lt;th&gt;Size (32-bits floats)&lt;/th&gt;
      &lt;th&gt;Size  (16-bits floats)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MobileNet-224&lt;/td&gt;
      &lt;td&gt;4.3&lt;/td&gt;
      &lt;td&gt;17.2 Mo&lt;/td&gt;
      &lt;td&gt;8.6 Mo&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VGG16&lt;/td&gt;
      &lt;td&gt;143.7&lt;/td&gt;
      &lt;td&gt;574.8  Mo&lt;/td&gt;
      &lt;td&gt;287.4 Mo&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;InceptionV3&lt;/td&gt;
      &lt;td&gt;23.9&lt;/td&gt;
      &lt;td&gt;95.6 Mo&lt;/td&gt;
      &lt;td&gt;47.8  Mo&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResNet-50&lt;/td&gt;
      &lt;td&gt;25.6&lt;/td&gt;
      &lt;td&gt;102.4 Mo&lt;/td&gt;
      &lt;td&gt;51.2 Mo&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;InceptionResNetV2&lt;/td&gt;
      &lt;td&gt;55.9&lt;/td&gt;
      &lt;td&gt;223.6 Mo&lt;/td&gt;
      &lt;td&gt;111.8 Mo&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;The models were instantiated via &lt;code class=&quot;highlighter-rouge&quot;&gt;keras.applications&lt;/code&gt; module with top layers, the number of parameters are given by &lt;code class=&quot;highlighter-rouge&quot;&gt;summary()&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It seems fair to say that simple computer vision models weigh easily ~100Mo. A hundred Mo &lt;em&gt;just&lt;/em&gt; to be able to make an inference isn‚Äôt a viable solution for an end product. A remote API can do the trick, but now your product needs to add encryption, you need to store and upload data, the user needs to have a reliable internet connection to have a decent speed. We can train a narrower network, they‚Äôll probably fit in a small memory. But chances are they won‚Äôt be good enough at extracting complex features.&lt;/p&gt;

&lt;p&gt;And we‚Äôre not talking about ensembles. Ensembles are a great way to extract a lot of knowledge from the training data. But at test time it can be too expensive to run a hundred different models in parallel. The knowledge per parameter ratio is quite low.&lt;/p&gt;

&lt;p&gt;In the end a model can have great score at training time, but we might want to: lower its size (for embedded systems), increase inference speed or simply reduce complexity. Geoffrey Hinton talks about reducing its ‚Äúmemory foot print‚Äù:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/kd-dist/moray-larvae.jpg&quot; alt=&quot;Larval Stage of Eels from cflas.org&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Many insects have a larval form that is optimized for extracting energy and nutrients from the environment and a completely different adult form that is optimized for the very different requirements of traveling and reproduction. In large-scale machine learning, we typically use very similar models for the training stage and the deployment stage despite their very different requirements (‚Ä¶) (&lt;a href=&quot;https://arxiv.org/pdf/1503.02531.pdf&quot;&gt;Distilling the Knowledge in a Neural Network&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Training a smaller model from a larger one is called knowledge distillation.&lt;/p&gt;

&lt;h2 id=&quot;-distillation&quot;&gt;üß™ Distillation&lt;/h2&gt;

&lt;p&gt;The authors continue that we are identifying knowledge with the values of the weights which makes it ‚Äúhard to see how we can change the form of the model but keep the same knowledge‚Äù. And remind us that we can see knowledge as a mapping from input to output.&lt;/p&gt;

&lt;p&gt;Knowledge distillation‚Äôs goal is to transfer the learning from one performant and heavy teacher to a more compact student.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/kd-dist/teacher-student.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To do so, we look at the teacher‚Äôs softmax layer, magnify it and the student learns how to produce them. We need to magnify because the softmax layer will smash down to zero the least probable classes and rises close to one the most probable (like one hot vector). We can also keep the relative probabilities between classes, where a motocycle and a bicycle share more similarities on the softmax layer rather than a book. We can do it by raising the temperature T.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://bit.ly/2P2INsc&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To transfer knowledge, a student is trained on the soften probabilities (T¬ª1) produced by a larger teacher. When the temperature T is smaller than one, the most expected classes will impact the most the final probability. Similarly, when increasing the temperature the probabilities will be softer/flattened across classes -you can have &lt;a href=&quot;https://www.desmos.com/calculator/gdcy4dvaje&quot;&gt;here&lt;/a&gt; an intuition of the influence of temperature on a single &lt;code class=&quot;highlighter-rouge&quot;&gt;exp()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First the teacher‚Äôs temperature is increased until a certain point. Then the student is trained to copy its teacher‚Äôs soft probabilities.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;labrador&lt;/th&gt;
      &lt;th&gt;cow&lt;/th&gt;
      &lt;th&gt;golden retriever&lt;/th&gt;
      &lt;th&gt;moto&lt;/th&gt;
      &lt;th&gt;bike&lt;/th&gt;
      &lt;th&gt;¬†&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;hard targets&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.8&lt;/td&gt;
      &lt;td&gt;10^-5&lt;/td&gt;
      &lt;td&gt;0.2&lt;/td&gt;
      &lt;td&gt;10^-9&lt;/td&gt;
      &lt;td&gt;10^-9&lt;/td&gt;
      &lt;td&gt;soft targets (T=1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.6&lt;/td&gt;
      &lt;td&gt;10^-2&lt;/td&gt;
      &lt;td&gt;0.45&lt;/td&gt;
      &lt;td&gt;10^-4&lt;/td&gt;
      &lt;td&gt;10^-4&lt;/td&gt;
      &lt;td&gt;soft targets (T¬ª1)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;benefits&quot;&gt;Benefits&lt;/h2&gt;

&lt;p&gt;Training on soft targets has several advantages: more information can be extracted from a single sample, training can be done on fewer examples, no need for labeled data&lt;/p&gt;

&lt;p&gt;The softmax of a multi-class classifier will give you higher probabilities for similar images. A rose may have similar soft probabilities with a tulip rather than a labrador. Similarly, two different classes are present in the same image, we might see it on the output. So &lt;strong&gt;more information&lt;/strong&gt; are extracted from each training sample.&lt;/p&gt;

&lt;p&gt;This is a consequence from the first point, the model can be trained on fewer training examples than the teacher. The learning is also &lt;strong&gt;faster&lt;/strong&gt; because there are more constraints on the student. It needs to target multiple (soft) outputs rather than a single (hard) one.&lt;/p&gt;

&lt;p&gt;Since the student learns from soft targets only, by relative similarities between classes, it can be trained on a &lt;strong&gt;unlabelled dataset&lt;/strong&gt;, using only the master has an on-fly ‚Äúsoft labeler‚Äù. But in practice, the dataset can be the same as the teacher.&lt;/p&gt;

&lt;h2 id=&quot;loss&quot;&gt;Loss&lt;/h2&gt;

&lt;p&gt;Distillation loss is generally in two forms: matching function values, matching derivatives or both, corresponding to a regression problem with different orders:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Matching function values: tries to minimize the difference between the predictions of the teacher and the student. For a classification task, this is done by using classical cross entropy.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Matching derivatives: tries to match the values &lt;em&gt;and&lt;/em&gt; the derivatives. This is a more efficient approach than before because here we can have full access to the teacher and we are able to measure the impacts of small variations in its inputs.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can also try to increase the influence of the prediction by adding directly the hard loss:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alpha ~= 0.1
KD_loss = alpha * log_loss(y_true, softmax(logits)) + logloss(y_true, softmax(logits/temperature))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can see a cool &lt;a href=&quot;https://github.com/Ujjwal-9/Knowledge-Distillation/blob/master/knowledge_distillation_for_mobilenet.ipynb&quot;&gt;implementation&lt;/a&gt; here.&lt;/p&gt;

&lt;h3 id=&quot;resources&quot;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=EK61htlw8hY?t=650&quot;&gt;TTIC Geoffrey Hilton - Dark Knowledge&lt;/a&gt; - presentation by the author of the first &lt;a href=&quot;https://arxiv.org/pdf/1503.02531v1.pdf&quot;&gt;Knowledge Distillation paper&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=oQr0gODUiZo&quot;&gt;IEE Security Symposium, Papernot&lt;/a&gt;:
Note that the distillation as a counter measure for adversarial examples has been proven to be not effective anymore.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name></name></author><summary type="html">Knowledge distillation is a fascinating concept, we‚Äôll cover briefly why we need it, how it works.</summary></entry><entry><title type="html">Machine Learning‚Äôs Security Layer, an Overview</title><link href="https://data-soup.github.io/blog/2018/10/02/machine-learning-security.html" rel="alternate" type="text/html" title="Machine Learning's Security Layer, an Overview" /><published>2018-10-02T15:39:28-05:00</published><updated>2018-10-02T15:39:28-05:00</updated><id>https://data-soup.github.io/blog/2018/10/02/machine-learning-security</id><content type="html" xml:base="https://data-soup.github.io/blog/2018/10/02/machine-learning-security.html">&lt;p&gt;This is a shallow overview of the security of machine learning systems. Within a few scrolls we‚Äôll go through:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ô∏è&lt;a href=&quot;#adversarial-examples&quot;&gt;Adversarial Example&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#model-theft&quot;&gt;Model Theft&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dataset-poisoning&quot;&gt;Dataset Poisoning&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dataset-protection&quot;&gt;Dataset Protection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;Ô∏èadversarial-examples&quot;&gt;Ô∏èAdversarial Examples&lt;/h2&gt;

&lt;p&gt;The adversarial examples (AE) topic is fascinating and an &lt;a href=&quot;https://arxiv.org/search/advanced?advanced=&amp;amp;terms-0-operator=AND&amp;amp;terms-0-term=adversarial+examples&amp;amp;terms-0-field=title&amp;amp;classification-computer_science=y&amp;amp;classification-physics_archives=all&amp;amp;classification-statistics=y&amp;amp;date-filter_by=all_dates&amp;amp;date-year=&amp;amp;date-from_date=&amp;amp;date-to_date=&amp;amp;size=50&amp;amp;order=-announced_date_first&quot;&gt;active&lt;/a&gt; area of research. It raises fundamental questions related to the limits and the security of our current gradient-based classifier architectures. AE are cleverly crafted data designed to be misclassified by a targeted model. They are ‚Äúdesigned to cause the model to make a mistake‚Äù (&lt;a href=&quot;https://blog.openai.com/adversarial-example-research/&quot;&gt;OpenAI&lt;/a&gt;, Attacking Machine Learning with Adversarial Examples). The image on the right is an adversarial example.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/ml-sec/adversarial-example-dog.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The difference between the left and the rightmost dog is probably unperceptible. This can be due to our eyes limitations (or the bit depth of your monitor).
And yet they are crucial to various models. The last image is indeed &lt;a href=&quot;https://github.com/maxpv/maxpv.github.io/blob/master/notebooks/Adversarial_ResNet50.ipynb&quot;&gt;considered&lt;/a&gt; as a &lt;code class=&quot;highlighter-rouge&quot;&gt;plane&lt;/code&gt; by a &lt;code class=&quot;highlighter-rouge&quot;&gt;ResNet50&lt;/code&gt; initialized with default training weight in Keras, and one AE will probably work on another architecture. The only difference are small pixels values, amplified in the second picture.&lt;/p&gt;

&lt;p&gt;We can notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;ResNet50&lt;/code&gt; was pretty confident that the dog on the left picture is a &lt;code class=&quot;highlighter-rouge&quot;&gt;golden_retriever&lt;/code&gt; (~80%) and the crafted image is a &lt;code class=&quot;highlighter-rouge&quot;&gt;plane&lt;/code&gt; with a higher confidence (~99%). So a model can be tricked into making a mistake with the confidence score we desire, we in general just need to train it long enough. What are the impacts of misclassifying with an arbitrary confidence score?&lt;/p&gt;

&lt;p&gt;Recommendation systems are also studied for &lt;a href=&quot;https://arxiv.org/pdf/1809.08336.pdf&quot;&gt;adversarial recommendation&lt;/a&gt;, influencing a recommendation system through indistinguishable fake users.&lt;/p&gt;

&lt;h4 id=&quot;safety&quot;&gt;Safety&lt;/h4&gt;

&lt;p&gt;In most known models, any image can be crafted into another class with an arbitrary confidence score.
So our dog can be misclassified as anything we wish with any arbitrary accuracy.
It has been shown that it works in the physical world too, for instance, if we &lt;a href=&quot;https://arxiv.org/abs/1607.02533&quot;&gt;print&lt;/a&gt; them. A famous example is tricking a car‚Äôs sensor to see
a speed limit instead of a STOP sign. The output of a model can be manipulated into making to some extent, a desired decision or at generating unhandled behavior by the application that relies on it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/ml-sec/street-signs.jpg&quot; alt=&quot;https://arxiv.org/pdf/1602.02697.pdf page 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;By the end of 2017 some showed that modifying one pixel can be enough in some cases. If you want to know more about this you can read
the paper &lt;a href=&quot;https://arxiv.org/abs/1710.08864&quot;&gt;One pixel attack for fooling deep neural networks&lt;/a&gt;, enjoy a high-level presentation by
the &lt;a href=&quot;https://www.youtube.com/watch?v=SA4YEAWVpbk&quot;&gt;One minute paper&lt;/a&gt; channel or check this &lt;a href=&quot;https://github.com/Hyperparticle/one-pixel-attack-keras&quot;&gt;Keras implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Adversarial examples are simple attack and don‚Äôt require much computation. On relatively small images a good GPU can craft an AE in less than a minute.
This is a real security issue and that is probably why we can read those line at the end of some related subject &lt;a href=&quot;https://arxiv.org/abs/1602.02697&quot;&gt;papers&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Research was also supported in part by the Army Research Laboratory, under Cooperative Agreement Number W911NF-13-2-0045 (ARL Cyber Security CRA), and the Army Research Office under grant W911NF-13-1-0421.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;different-threats-level-and-techniques&quot;&gt;Different threats level and techniques&lt;/h4&gt;

&lt;p&gt;We know that adversarial examples play with the decision boundaries of a classifier. We can, for instance, add random pixels on an image and &lt;em&gt;change&lt;/em&gt; the classification or wisely choose those added pixels and &lt;em&gt;choose&lt;/em&gt; the classification. Depending on the threat objective we denote:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Confidence reduction increases the ambiguity between classes by reducing the model‚Äôs confidence for a given image.&lt;/li&gt;
  &lt;li&gt;Misclassification changes the output class to &lt;em&gt;another&lt;/em&gt; class than the original one.&lt;/li&gt;
  &lt;li&gt;Targeted misclassification forces the output of a specific input to be a specific target class.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Depending on the opponent‚Äôs knowledge, there are three ways of crafting adversarial examples. Each with their own assumed prior knowledge of the target. Knowing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the model as a whole including its weights (&lt;em&gt;gradient-base&lt;/em&gt;),&lt;/li&gt;
  &lt;li&gt;only the score of each class (&lt;em&gt;score-based&lt;/em&gt;),&lt;/li&gt;
  &lt;li&gt;only the prediction (&lt;em&gt;transfer-based&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A simplified copy of a diagram by Papernot. et al in The Limitations of Deep Learning in Adversarial Settings (page 3):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/ml-sec/threat-model-taxonomy.png&quot; alt=&quot;Simplified copy of a diagram by Papernot. et al in The Limitations of Deep Learning in Adversarial Settings (page 3)&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One example of &lt;strong&gt;gradient-base attack&lt;/strong&gt; consists in computing the loss‚Äô gradient function an image. Following by a tiny step in the opposite gradient‚Äôs direction. In order to keep valid RGB values, the image might be clipped between 0 and 255 and the value of the noise between 0 and a small value, M.
This value M determine the maximum difference between the original image and the adversarial one, so M should be smaller than a human‚Äôs color sensibility (through a monitor). M smaller than 5 should be fine.
The previous technique is called the iterative least-likely class method. Other types of gradient techniques exist like a fast gradient sign method. You can read &lt;a href=&quot;https://arxiv.org/abs/1607.02533&quot;&gt;this paper&lt;/a&gt; (part 2, page 3). We can note that they all require a complete knowledge of the model and its weights.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Score-based attacks&lt;/strong&gt; rely only on the predicted model‚Äôs score to estimate the gradient and then apply the previous technique.
&lt;strong&gt;Transfer-based attacks&lt;/strong&gt; rely exclusively on the output label. This is a more realistic scenario compared to score-based and gradient-based. You can find
an example of a transfer-based attack in the section Model Theft.&lt;/p&gt;

&lt;h4 id=&quot;defence&quot;&gt;Defence&lt;/h4&gt;

&lt;p&gt;Here we won‚Äôt go much in depth I encourage you to search the keywords that attract you, it deserves a blog post on its own. We can see two big categories of defences:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;Reactive&lt;/em&gt;: where the objective is an adversarial example prior being called on by our model for an inference.&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;Proactive&lt;/em&gt;: where the objective is to make the models more resilient to this kind of attack.
&lt;a href=&quot;https://arxiv.org/abs/1602.02697&quot;&gt;Black Box Attacks&lt;/a&gt; by Nicolas Papernot et al.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example of reactive defenses:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1705.09064&quot;&gt;MagNet&lt;/a&gt; a ‚Äòtwo networks‚Äô model composed of an auto-encoder capable of reforming before being fed to a classifier. Several auto-encoder are needed here so it‚Äôs resource expensive.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example of proactive defenses:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1806.05789&quot;&gt;Random depthwise signed convolutional neural networks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Label smoothing (2016)&lt;/li&gt;
  &lt;li&gt;Mixup (2017)&lt;/li&gt;
  &lt;li&gt;Adversarial training, re-training the neural network with a subset of adversarial examples&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.google.com/search?&amp;amp;q=logit+pairing+neural+network&quot;&gt;Logit pairing&lt;/a&gt; this one is very new (2018) and ‚Äúachieves the state of the art defense for white box and black box attacks on ImageNet‚Äù&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;model-theft&quot;&gt;Model Theft&lt;/h2&gt;

&lt;p&gt;Trying to rebuild someone‚Äôs else model or retrieve data that were used to train the model. The dataset and or the model might be confidential for their sensitive or commercial value.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The tension between model confidentiality and public access motivates our investigation of model extraction attacks. (&lt;a href=&quot;https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_tramer.pdf&quot;&gt;Source&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We‚Äôll summarize briefly the &lt;a href=&quot;https://arxiv.org/abs/1602.02697&quot;&gt;Black Box Attacks&lt;/a&gt; by Nicolas Papernot et al. If you want to dig this subject you might enjoy reading it. The main idea described here is to create a local substitute neural network trained with a substitute dataset crafted by the adversary. Then, using gradient-based techniques adversarial examples can be generated.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/ml-sec/flowchart-black-box-attack.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There‚Äôs no need for a labeled dataset, which can be expensive to produce. The substitute dataset is labeled using the remote DNN‚Äôs output.
Then the local dataset is locally augmented through a technique called &lt;em&gt;Jacobian-based Dataset Augmentation&lt;/em&gt;.
Here is a pseudo code describing the Jacobian data augmentation (full code available on &lt;a href=&quot;https://github.com/tensorflow/cleverhans/blob/023c3061f073e09204285949c85122da42e43d63/cleverhans/attacks_tf.py&quot;&gt;github&lt;/a&gt;).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def jacobian_augmentation(dataset):
  &quot;&quot;&quot;
  - get_label: API call on the remote oracle
  - alpha: step size
  - jacobian: returns jacobian matrix of the substitute model
  &quot;&quot;&quot;
  jacobian_dataset = []
  for sample in dataset:
    label = get_label(sample)
    jacobian_sample = sample + alpha*sign(jacobian(substitute_model, label))
    jacobian_dataset.append(jacobian_sample)

  return jacobian_dataset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Basically, each example is augmented by adding a small variation in direction of the gradient.&lt;/p&gt;

&lt;p&gt;They emphasize that:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[‚Ä¶] this technique is not designed to maximize the substitute DNN‚Äôs accuracy but rather ensure that it approximates the oracle‚Äôs decision boundaries with few label queries.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The choice of architecture isn‚Äôt very important since we can assume some details beforehand. There is a high chance that a CNN was used for an image classification task. It is also possible to train simultaneously several architectures.&lt;/p&gt;

&lt;p&gt;An implementation of a similar attack is available on &lt;a href=&quot;https://github.com/labsix/limited-blackbox-attacks&quot;&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;dataset-poisoning&quot;&gt;Dataset Poisoning&lt;/h2&gt;

&lt;p&gt;Dataset poisoning attacks aim at manipulating model‚Äôs behavior at test time.&lt;/p&gt;

&lt;p&gt;Poisoning 3% of a training set managed to drop the test accuracy by 11% (&lt;a href=&quot;https://arxiv.org/abs/1706.03691&quot;&gt;Certified Defenses for Data Poisoning Attacks&lt;/a&gt; by Steinhardt at al. (2017)).&lt;/p&gt;

&lt;p&gt;Label flipping attack the objective is to maximize the loss function if a subset of the training example‚Äôs label is flipped, this is basically done by gradient ascent:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/ml-sec/clean-label-attack.png&quot; alt=&quot;Ali Shafahi et al. 2018 (Figure 1-b)&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An attacker first chooses a target instance from the test set; a successful poisoning attack causes this target example to be misclassified during test time. Next, the attacker samples a base instance from the base class, and makes imperceptible changes to it to craft a poison instance; this poison is injected into the training data with the intent of fooling the model into labeling the target instance with the base label at test time. Finally, the model is trained on the poisoned dataset (clean dataset + poison instances). If during test time the model mistakes the target instance as being in the base class, then the poisoning attack is considered successful
&lt;a href=&quot;https://arxiv.org/pdf/1804.00792.pdf&quot;&gt;Poison Frogs! Targeted Clean-Label Poisoning Attacks on Neural Networks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;dataset-protection&quot;&gt;Dataset Protection&lt;/h2&gt;

&lt;h3 id=&quot;fully-homomorphic-encryption&quot;&gt;Fully homomorphic encryption&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/ml-sec/fhe-neuralnetwork.png&quot; alt=&quot;Fast Homomorphic Evaluation of Deep Discretized Neural Networks https://eprint.iacr.org/2017/1114.pdf page 25&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fully homomorphic encryption is an encryption scheme that preserves the operation on data through encryption and decryption function. If the scheme is preserved over the addition, encrypting a sum or summing the encrypted members will give the same result.
This means that you can encrypt your data locally and send it to a server, let it do a job using only the supported operators and return you the encrypted result. You don‚Äôt need to trust the server since it won‚Äôt understand what it is manipulating.&lt;/p&gt;

&lt;p&gt;Let &lt;code class=&quot;highlighter-rouge&quot;&gt;ENC&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DEC&lt;/code&gt; the encryption and decryption function respectively:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENC(X1 + X2) = ENC(X1) + ENC(X2) (homomorphism)
Since X1 + X2 = DEC(ENC(X1+ X2))
We have X1 + X2 = DEC(ENC(X1) + ENC(X2))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you would need to follow one person in this field, it would be &lt;a href=&quot;https://researcher.watson.ibm.com/researcher/view.php?person=us-cbgentry&quot;&gt;Craig Gentry&lt;/a&gt;. He found the first FHE scheme in 2009.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Much of Craig‚Äôs recent work, including FHE and cryptographic multilinear maps, generally falls into the area of ‚Äúlattice-based cryptography‚Äù. Unlike commonly-used cryptosystems like RSA and elliptic-curve cryptography, lattice-based cryptosystems cannot feasibly (as far as we know) be broken by quantum computers. (&lt;a href=&quot;https://researcher.watson.ibm.com/researcher/view.php?person=us-cbgentry&quot;&gt;IBM&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The most important part here is that if one day this encryption schemes exists we can (almost) not care about the privacy of our data we‚Äôre sending on a remote machine. If this machine is malicious it can just give you wrong results but can‚Äôt exploit your data‚Ä¶
Unless‚Ä¶ If we‚Äôre talking about an FH encrypted machine learning model trying to predict something, nothing guarantees you that the model is empty at first and your opponent can still do inferences on the young model (by observing boundaries decisions and such). You should check out &lt;a href=&quot;https://arxiv.org/abs/1711.05189&quot;&gt;CryptoDL&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;dataset-theft&quot;&gt;Dataset theft&lt;/h3&gt;

&lt;p&gt;It is also possible to recover the data used  at training by simply looking at the model‚Äôs output, &lt;a href=&quot;https://arxiv.org/abs/1610.05820&quot;&gt;Membership Inference Attacks Against Machine Learning Models&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;given  a  data  record  and  black-box  access  to a  model,  determine  if  the  record  was  in  the  model‚Äôs  training dataset. To perform membership inference against a target model, we make adversarial use of machine learning and train our own inference  model  to  recognize  differences  in  the  target  model‚Äôs predictions  on  the  inputs  that  it  trained  on  versus  the  inputs that  it  did  not  train  on.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An implementation can be found &lt;a href=&quot;https://github.com/csong27/membership-inference&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;</content><author><name></name></author><summary type="html">This is a shallow overview of the security of machine learning systems. Within a few scrolls we‚Äôll go through:</summary></entry></feed>